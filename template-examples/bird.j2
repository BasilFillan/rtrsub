{#

Common RPKI functions to use with BIRD

reject_rpki_invalid() - implicit arguments
	depends on these two functions:
		- is_roa_covered_prefix() - implicit arguments
		- complies_with_roa() - implicit arguments
	to be applied on each and every EBGP session

origin_to_roa(int asn)
	to be used to accept prefixes from an adjacent ASN
	if no IRR route object exists, but a valid ROA + announcement exist.
#}

define myas = 197032;
define accepted = 1;
define rejected = 2;
define a_rpki_valid = 1;
define r_rpki_invalid = 1;

function is_roa_covered_prefix()
prefix set roas;
{
     roas = [
        {% for prefix in pfx_dict -%}
{{ prefix }}+
{%- if not loop.last -%},{%- endif -%}
{{ "\n        " }}
{%- endfor %}
    ];

    if net ~ roas then {
        return true;
    }
    else return false;
}

function complies_with_roa()
{
{%- for prefix in pfx_dict %}
{%- if pfx_dict[prefix]["prefixlen"] == pfx_dict[prefix]["maxlength"] %}
    if net = {{ prefix }} then {
{%- else %}
    if net ~ [ {{ prefix }}{{ "{" }}{{ pfx_dict[prefix]["prefixlen"] }},{{ pfx_dict[prefix]["maxlength"] }}{{ "}" }} ] then {
{%- endif %}
{%- for origin in pfx_dict[prefix]["origins"]|sort(reverse=True) %}
{%- if origin == 0 %}
        return false;
{%- else %}
        if bgp_path.last = {{ origin }} then return true;
{%- endif %}
{%- endfor %}
     }
{%- endfor %}
     return false;
}


{%- for origin in origin_dict %}
define roas_AS{{ origin }} = [
        {% for prefix in origin_dict[origin] -%}
{%- if origin_dict[origin][prefix]['length'] == origin_dict[origin][prefix]['maxlength'] -%}
{{ prefix }}
{%- else -%}
{{ prefix }}{{ "{" }}{{ origin_dict[origin][prefix]['length'] }},{{ origin_dict[origin][prefix]['maxlength'] }}{{ "}" }}
{%- endif -%}
{%- if not loop.last -%},{%- endif -%}
{%- if loop.index % 4 == 0 -%}
{{ "\n        " }}
{%- else -%}
{{ " " }}
{%- endif -%}
{%- endfor -%}
    ];
{% endfor %}

function origin_to_roa(int asn)
{
    case asn {
{%- for origin in origin_dict|sort() %}
        {{ origin }}: return net ~ roas_AS{{ origin }};
{%- endfor %}
    }
    return false;
}

function reject_rpki_invalid()
{
    if is_roa_covered_prefix() then {
        if complies_with_roa() then {
            /* add marker to routes for which a valid matching ROA exists */
            bgp_large_community.add((myas, accepted, a_rpki_valid));
        }
        else {
            print "Reject: ROA check failed for ", net, " ", bgp_path, " protocol: ", proto;
            bgp_large_community.add((myas, rejected, r_rpki_invalid));
            reject;
        }
    }
}
